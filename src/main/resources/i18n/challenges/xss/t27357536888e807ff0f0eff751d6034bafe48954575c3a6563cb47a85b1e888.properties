challenge.challengeName = Cross Site Scripting Two
challenge.description = <p>This challenge has an XSS filtering function, it filters most of the js events such as onerror, onmouseover, etc. By implementing such filtering when you are trying to fix an XSS vulnerability, you will fail most of the time because you can&#39t always cover everything.</p><p>There will be always an event, keyword, path, etc that you forgot about it and someone will be able to find it and bypass the filtering.</p><p> Conclusion: Don&#39t rely only on filtering, add additional measures such as:</p><ul><li><b>Filter input on arrival</b>. At the point where user input is received, filter as strictly as possible based on what is expected or valid input.</li><li><b>Encode data on output.</b> At the point where user-controllable data is output in HTTP responses, encode the output to prevent it from being interpreted as active content. Depending on the outputcontext, this might require applying combinations of HTML, URL, JavaScript, and CSS encoding.</li><li><b>Use appropriate response headers.</b> To prevent XSS in HTTP responses that aren&#39t intended to contain any HTML or JavaScript, you can use the Content-Type and X-Content-Type-Options headers to ensure that browsers interpret the responses in the way you intend.</li><li><b>Content Security Policy.</b> As a last line of defense, you can use Content Security Policy (CSP) to reduce the severity of any XSS.</li></ul><p>Find a XSS vulnerability in the following form. It would appear that your input is been filtered!</p>
challenge.form.instruction = Please enter the <a>Search Term</a> that you want to look up
challenge.form.getUser = Get this user

sign.loading = Loading
sign.hint = Would you like a hint?

error.occurred = An Error Occurred